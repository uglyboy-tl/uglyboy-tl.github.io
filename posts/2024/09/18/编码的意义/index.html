<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>编码的意义 | 拾柒读库</title>
<meta name=keywords content="LLM,编码"><meta name=description content="大模型发挥能力被忽视的要素"><meta name=author content="癸老师"><link rel=canonical href=https://blog.uglyboy.cn/posts/2024/09/18/%E7%BC%96%E7%A0%81%E7%9A%84%E6%84%8F%E4%B9%89/><meta name=google-site-verification content="3G6_t7vAxMLWAnWZ3vEdzO31bCfdUbjWEHHCL_KDnjw"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.d73d5a01dbf379e7897a3627eff85bf83c060878b9f292d177847340a76d2c8d.css integrity="sha256-1z1aAdvzeeeJejYn7/hb+DwGCHi58pLRd4RzQKdtLI0=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.uglyboy.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.uglyboy.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.uglyboy.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.uglyboy.cn/apple-touch-icon.png><link rel=mask-icon href=https://blog.uglyboy.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://blog.uglyboy.cn/posts/2024/09/18/%E7%BC%96%E7%A0%81%E7%9A%84%E6%84%8F%E4%B9%89/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://blog.uglyboy.cn/scss/main.min.bb0f243946b87c8f66307b9c43939ead878278180e8edada628b0d7ecd38edfc.css integrity="sha256-uw8kOUa4fI9mMHucQ5OerYeCeBgOjtraYosNfs047fw=" media=screen><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{enableExplorer:!1,skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src=https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/7.12.1/polyfill.min.js integrity="sha512-uzOpZ74myvXTYZ+mXUsPhDF+/iL/n32GDxdryI2SJronkEyKC8FBFRLiBQ7l7U/PTYebDbgTtbqTa6/vGtU23A==" crossorigin=anonymous referrerpolicy=no-referrer></script><script crossorigin=anonymous integrity="sha512-6FaAxxHuKuzaGHWnV00ftWqP3luSBRSopnNAA2RvQH1fOfnF/A1wOfiUWF7cLIOFcfb1dEhXwo5VG3DAisocRw==" src=https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.min.js></script><link crossorigin=anonymous integrity="sha512-YZW7jSV4QrwpPzFxB77lAW4qNIeS6RaipaStONrpmbJsyh3zxM/3VoeQrrGlYkNS5nIjsKFURRHnsKhmE/vWmg==" href=https://lib.baomitu.com/lxgw-wenkai-webfont/latest/style.min.css rel=stylesheet><style>body,section{font-family:lxgw wenkai,sans-serif}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-0T89SF4PSW"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-0T89SF4PSW")}</script><meta property="og:url" content="https://blog.uglyboy.cn/posts/2024/09/18/%E7%BC%96%E7%A0%81%E7%9A%84%E6%84%8F%E4%B9%89/"><meta property="og:site_name" content="拾柒读库"><meta property="og:title" content="编码的意义"><meta property="og:description" content="大模型发挥能力被忽视的要素"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-18T10:38:40+08:00"><meta property="article:modified_time" content="2024-09-26T10:27:32+08:00"><meta property="article:tag" content="LLM"><meta property="article:tag" content="编码"><meta name=twitter:card content="summary"><meta name=twitter:title content="编码的意义"><meta name=twitter:description content="大模型发挥能力被忽视的要素"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://blog.uglyboy.cn/posts/"},{"@type":"ListItem","position":2,"name":"编码的意义","item":"https://blog.uglyboy.cn/posts/2024/09/18/%E7%BC%96%E7%A0%81%E7%9A%84%E6%84%8F%E4%B9%89/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"编码的意义","name":"编码的意义","description":"大模型发挥能力被忽视的要素","keywords":["LLM","编码"],"articleBody":"导言 伴随着大模型研究的推进和在应用中的实践，我们发现了一个现象——对于现有的 LLM 模型而言，一个好的编码可能会对其模型能力带来极大的助力。\n关于这方面的思考其实由来已久，早前在听闻“压缩即智能”的论断，以及相关的数学阐述时，就产生过一种奇妙的念头：\n如果我们对我们正常的语言进行编码压缩，这样得到的文本信息的压缩率会更高，对压缩过的文本再进行 LLM 的训练，会发生什么？ LLM 生成的编码还能被正常的解压缩成文本吗？解压缩之后的文本还能流畅通顺吗？ 这样训练出的 LLM 会不会压缩率更高？那它会更加智能吗？ 后来，在搞清楚了“压缩即智能” 那篇演讲，背后所提到的压缩 概念，不过是算术编码的基础运用后，这种思考便放下了 1。\n现在重新聊回编码问题，从编码的角度来看看 LLM 的本质。\n信息和熵 回归到 LLM 的模型范式，过去的研究主要都将重点集中在了 Transformer 和深度学习的神奇泛化能力方面，通过更大规模的训练（Scaling Law），降低泛化误差。但究其本质，训练的逼近只是一个数值优化（压缩映射）的过程，优化的目标才是这件事起到作用的关键。\nLLM 更应该叫大编码模型 LLM 是信息预测模型：利用时序上已知的信息，对下一个时刻出现的信息进行预测。\n但信息本身是需要被表征出来，才能进行读取（理解）和预测，而信息的表征方式就是编码。\n多模态的大模型相比于文本大模型本质上没有任何不同之处，仅仅是表达信息的编码不同，认为多模态比基于文本的大模型拥有更丰富的信息这一点是存疑的。但这一点还不是多模态大模型最大的问题。\n另一个十分重要的因素，就是多模态的编码相比于语言这种编码，在进行预测时很可能天然就有十分巨大的劣势。这一点将在后文中引入了信息度量：“熵”之后，进行更深入的讨论。\n大模型的内核，正是基于已有的编码的信息，预测新的编码。预测的具体内容，是新编码出现的概率。\n这里会有一个思考，不同的编码方式，是否会对预测本身的质量产生影响呢？\n从实践的角度来看，是有很大影响的。所以大语言模型都会有自已的 embedding 算法，而不是直接使用字母表或者 unicode 编码进行分析。\n但我们如何从理论的解读来理解和分析这个结果呢？我们很需要引入一个能更好的描述编码相关特性的物理量。\n而在数学中刻画信息、编码、概率的模型是香农的信息论。其中最深刻的刻画就是信息熵。\n熵 熵的概念，本质上是一个系统里单位时间内的信息密度，或者说，是我们对未来时刻进行预测的难度。\n所以自然的，一个时刻出现的概率非常的低，那么这一刻我们对未来的预测就会非常的难；同时因为熵是个可描述的物理量（具有可加性），自然就会引出其常见的定义方式：\n$$ H = - \\sum p \\ln p $$\n在这个意义下，Boltzmann 熵、Gibbs 熵 和 香农的信息熵是一致的。于是很容易引入一个十分热门的概念：热力学第二定律。\n热力学第二定律 [!tip] 热力学第二定律\n在不受任何外部影响的条件下，一个系统的熵会不断增加。更具体的说，就是系统中的每个个体都会走向更加随机（概率更小），导致整个系统的可预测性越来越低。\n需要注意的是，热力学第二定律并不是一个完美的时序判别器，它是一个概率性的时间方向指引：\n也就是说可能会存在很多个瞬间，系统的熵减少了； 甚至一定存在某个很极端的概率事件——系统的熵一直在减少； 但这些都是概率空间上的正常表现，宏观视角来看，熵的增加是稳定的。\n在这种情况下，我们很容易发现，信息几乎是不可预测——随着信息中的要素的增加，想要预测下一时刻的信息所需要的信息量会按照热力学第二定律，不断增加，直至不可计算 2。\n为了更好的理解熵和不可计算，我们以三体问题为例。\n我们要想预测三体未来一小段时间的运动轨迹，所需要的信息是在这一时刻前更长一段时间的历史三体运动信息，获得的历史运动信息越多越精准，对未来的预测就能越精准，预测正确的时间就会更长一些。但永远没办法做到像计算行星轨道一样，给出公式性的结果，这种情况就属于不可计算。\n从三体出发，如果想预测四体，需要比三体更加庞大的数据量才足以支撑相同时间长短的预测。随着 $n$ 体中 $n$ 的不断增长，我们能够有效的预测的时间就会越来越小。\n这种现象背后的数学基础是动力系统中的混沌现象，本文不对这个问题进行更深入的解读，对此有兴趣可以参考我的《系统理论》进行理解。\n编码 编码不是物理学自然的结果，编码是随着生物的出现而出现的。更聚焦的说，编码是生物体对于一些固定特征合集的概括。尤其是，编码的出现，其实意味着某些固定特征合集的重复出现（高概率）。而从信息论出发，对于高概率的事件，通过编码（更短的信号）传递，就可以更高效的表达信息。\n编码的出现其实也意味着人们对信息的控制（熵减）——因为编码的表达（例如动作，叫声）本身，也是编码的一部分，都属于某种小概率的行为。但当这种行为被赋予编码的含义，反过来也意味着这种行为的出现频率将会变高，于是这种行为的熵变小，进而可预测性提升。\n编码不仅仅是对客体的描述，也是对客体的控制，进而在局部可以逆转 3 热力学第二定律。因为编码意味着一种控制行为，也就带来了可预测性的提升。\n这个结论也昭示了本文的核心观点：好的编码才是 LLM 进行预测的关键。\n这也是为何 LLM 最早在 NLP 和 Coding 领域取得成功，因为这两者背后都依托于非常良好的编码。\n编码的质量 有了编码的帮助，生物就可以更好的控制自身和外部环境之间的交互，让原本更加随机不可控的生存，变得更加可控了。而这种控制的方式，就是通过编码，让随机事件中的小概率变得不那么随机（更有确定性），系统的熵降低了，但被编码的事件（信息）的熵 4 增加了。\n所以系统更加可预测 -\u003e系统的熵降低 -\u003e信息编码的熵增加。\n其实这件事在香农的信息论里本来就是比较显然的结果——更好的编码是按照信息的熵值大小进行编码的。甚至所谓的“压缩即智能”中的算术编码，也是自然的香农信息论的编码结果。\n编码的演进 如果客观世界是无法被改变的，那么最优的编码是固定的，几乎不存在编码的选择问题。\n不过编码是主观的，是生物控制自身适应环境的工具。所以编码是不断演进的，甚至编码本身的演进就是一种控制客观存在的能力的提升（例如计算机代码）。\n所以我们需要从演进的视角来观察编码变化带来的价值，进而了解我们需要怎样的编码来更好的进行预测和控制。\n一些编码演进的案例 [!example] 从成语看语言的演进\n各种语言的演进都是从拟声词开始的，而且这种能力并不是人类所独有，很多生物都会有自己的一些独特的信息编码表达（包括不同的叫声，也包括用排泄物标识领地等等）。\n相比于动物，人类的独特之处在于创造了更多的编码，并开始组合使用这些编码。于是很多简单概念的编码就连接起来，形成了句子，形成了语言。\n有了语言以后，人们就有能力更加便捷的传播信息，于是很多信息打包在一起，形成了故事，再进行传播。而这里则又出现了一次重要的编码演化——当故事传播后，它自身就成了一个编码，蕴含了远比普通的拟声表达、简单词语、句子更加丰富的内容。\n这种组合，在不同的语言不同的地域有不同的表现形式，有的叫典故、有的会形成歇后语、而在汉语中，运用了一种比较独特的编码形式——成语，用四个字的方式将大量的类似的故事进行编码和传播，进一步提升了汉语的熵。\n并且有了成语这种编码，再回到一般的语言表达时，句子的信息含量也得到极大的提升，甚至可以通过多个成语，再次形成新的成语，不断演进这个过程。\n[!example] Python 和 JavaScript\n单从语言效率的方面来评判，Python 和 JavaScript 都算不得是很优秀的编程语言。但近些年，这两种编程语言却超越了传统的 C、C++ 和 Java，成为了最流行的编程语言，这背后也是编码演进的功劳。\n首先，Python 和 JavaScript 语言最大的特点都是入门简单，于是先天就会都拥有大量的普通用户。普通的用户对于编程语言没有很专业的训练，更需要的是简单快速可实现的能力，于是正应对上了 Python 和 JavaScript 发展中最重要的能力——包管理。\n一个 Python 项目或者 JavaScript 项目，往往都会伴随一个巨大的第三方依赖文件夹，用 pip 或 npm 在项目中引入了巨量的代码，但对用户而言，在使用编程语言时，对于大量复杂的功能的使用，则只需要简单的接口或者函数就能实现，而不再需要关心各种通用功能的细节，让普通用户也可以实现复杂而高级的能力。\n这种包引用的方式，其实就是编程语言的一种演进——将大量复杂的信息组合后，用新的编码来替代，就可以让编码的熵得到提升，进而让普通人也可以使用上（预测出）更可控的编码来控制外部世界。这个例子的说明了，好的编码确实可以让编码的预测性变得更好。\n更直接的例子，现在无论哪种编程语言，进行数学计算时，都会直接用数学表达式进行表达，而不会用汇编将每一次的加法进行各种位移操作。这样才使得我们操控编码变得更加有效。\n[!example] 数学\n数学的发展史是极度依赖数学符号（编码）的演进的。今天的人可以比古人更明白数理，数学符号（编码）功不可没。\n数学符号发展的第一步是从数演变成数字——即用具体的编码来指代不同的数量，而不是用数量本身来指代数量。这种变化才能让人类对数量的认知从 $10$ 以内（手指的数量），扩充到更多。\n有了数字后，下一个重要的演进则是用不同的位置来标识不同的数字，也就是我们现在熟悉的进位制。这之后，大量级的数字才有机会被统计和计算，人类才真正将数学变成一个工具。\n然后是分数的概念 5。或者更准确的说法，是除法的出现和表达。人们终于可以一定程度上在连续的数域上进行管理和控制。\n虽然第一次数学危机引入了无理数，对数学史意义重大，但从数学的发展来看，无穷的出现和编码，才是真正的突破。有了对于无穷的理解，才有了后来牛顿的微积分（牛顿对于微积分的最重要贡献也是微积分的符号），数学才步入了近代的发展。\n这之后，人们愈发理解了数学符号对数学发展的重要性，数学符号的演进也是飞速的，不再成为数学发展的掣肘。\n[!example] 技术的演进\n技术的演进其实也是编码化的——每一种新的技术都会有自己的编码描述，然后各种新技术（编码）进行重组，又会形成新的编码，提升技术的熵值，让人们可以控制更加难以控制（自然发生的概率更小）的事物。\n例如元素周期表的出现就极大推动了化工以及材料、健康、能源、农业等相关产业的发展。元素周期表之前，少数的化学家也可以掌握一些物质的性质和信息，但组合使用是需要极高的门槛的。有了元素周期表，有了化学物质的新命名方式，以及更容易计算的化学反应方程，对于普通高中生而言一般的化学变化都可以轻松掌握。\n类似的，每一种技术的发展，其实背后都是对应的编码的演进过程。如前面 Python 和 JavaScript 的例子是这样；工业生产、供养链、产业带的演进等等都是这样的过程。所以最终技术的成功不依赖于最初技术编码设计的是否巧妙，而是在于技术编码演进的过程中，对应的编码是否逐渐拥有了更大的熵。\n以当下人类工业的顶点——光刻机为例，组装光刻机的企业并不掌握全部的工业技术，而是掌握了很多的技术编码，对编码进行组装；而上游的很多企业也只掌握了特定编码的生产，甚至也是更低级编码的组装。但足够复杂的编码构成，最终才形成了现在的可以按纳米级控制生产原件的机器的诞生。\n编码的进化 我们如何进一步提升编码的信息熵，让编码变得更好？从上文的几个案例中，其实可以找到一些共通点。\n编码是需要不断组合，进而形成更加高级的概念。由此不断的可以控制客观发生概率更小的事情。\n客观的物理世界中随机出现一个 iPhone 手机基本是不可能的。我们人类是如何通过编码的控制创造了批量制造 iPhone 的方式呢？\n我们需要 集成电路 这个编码，需要 电池 这个编码，需要 高清屏幕 这个编码，同时这些编码也不是天然存在的，是更往前的历史长河中，由更加基础的编码组合而成的。\n所以当我们需要 iPhone 时，会拆解成 集成电路、电池、高清屏幕、……等等的概念，而这些概念继续拆解，直至拆解到类似于 硅、胶水、玻璃 等等相对基础的编码，用流程化的工程手段一步步组合成最终的高级的 iPhone 手机。这些编码就是人们控制生产的完整流程，有了这些编码组合，生产出 iPhone 就变成了一件确定性，可预测的时间了。\n编码进化的方式遵循着进化的三条基本规则：\n自然选择：被使用得更多（概率更大）的编码会被保留下来； 基因漂变：某一个编码的对应的信息会小幅度的进行一定程度的变化，以更好的适应自然选择； 基因重组：形成新的编码的更高效的方式，就是两个已经存在的编码进行一定程度的关联，如果能够顺利关联上，就可以快速组合出新的优质编码。 编码不是信息组合 从前面的分析，我们知道高级的编码是很多低级编码的组合，因此蕴含了极大的信息熵，从而更好的控制了客观世界。\n那么编码仅仅是信息打包的组合吗？或者更具体的说，人们使用编码的时候，需要能完全的理解编码背后的全部低级编码组合吗？令人庆幸的是，并不需要。当一个编码形成后，编码自身就已经是独立的控制手段了。大家可以通过编码交流，但并不需要完整的交流编码背后的全部信息，即可实现信息和控制的传递。\n关于中心极限定理，其数学表达和证明并不是很显然的，也不是未经训练的人就可以快速掌握的。\n但它的直接结果：正太分布，却可以十分常见的应用于人们对外部世界的控制。\n所以编码本身不能简单的看作是信息组合的标识符，编码存在本身就已经意味着重要的意义。\n进化的结果是熵减（更可控） 编码的意义是指向一块小概率（自然发生的概率）的空间；通过编码进行的控制其实就是意欲将解空间限制在这块空间附近，进而提升解落在这块空间中的概率。于是编码就带来了熵减，而从应用的角度来理解，就是编码对应的行为更可控（可预测）。\n而编码的进化过程，则是一种可持续的熵减演进的过程，带来结果的更加可控和可预测。\n反过来这也说明了，哪怕是同一种编码，经过了不断进化后，也会提升其可预测性。这其实也反映了 LLM 的能力是收到编码的制约的——编码本身提供了可预测性的天花板。糟糕的编码 6 在 LLM 中也很难取得突出的效果。\n编码与 LLM LLM 的目标和能力是对编码进行预测。通过上文的分析，我们已经知道，编码的作用原本就是是为了生物控制外界而诞生的；同时编码的演进方向其实也正是为了让编码变得更容易预测（增大解空间）。所以：\n好的 LLM 可以很好的复原编码的预测性（LLM 可以像人一样使用编码）； 好的编码可以提升 LLM 的可预测性； 语言编码 语言编码是当下最适合 LLM 的编码。也正如我们感受到的一样，LLM 在单纯的语言能力方面，已经达到甚至超过了人的能力。\n因为语言编码经过千万年的演进，已经是一个比较优良的编码了。也正是因为这个原因，LLM 才被称为 Language 模型，而不是一个编码模型。\n甚至可以说，在语言编码方面，LLM 已经进化到了极致——对编码本身的利用率已经几乎压榨到底了。甚至并不需要特别大的模型，就可以很好的利用语言编码的能力了（例如 14b 以下的小模型）。\nCode 编码 编程语言是人类设计出来的编码，同时参考了很多自然语言的用法和逻辑，尤其是有了包管理的概念后，Code 编码的演进速度甚至超过了语言编码。加上 Code 的语法相比语言更加严格（解空间更小），带来的熵减也比语言编码更多一些，所以具有更好的可预测性（可控性）。\n所以 LLM 对 Code 编码的利用能力也是各种编码中最好的。面向未来的话，利用 LLM 解决 Coding 相关问题的能力一定也将会是率先迎来突破的领域（Cursor 已经初步展示了这种能力，并不需要利用更大的 LLM，现有的 LLM 甚至更小的都足够完成这种能力上的质变）。\n数学编码 数学的逻辑推理其实是十分严格的编码语言，同时数学的各种定理也足以构成更高级的编码。在这个意义上来说，数学编码将会是未来能取得重要突破的领域。\n当下的问题是，lean 语言作为数学的编码，其语料太少，非常多的基础定理都还尚未被 lean 语言描述出证明过程。这使得 LLM 可利用的编码所蕴含的熵很少，所以可预测性很低。\n类似于人做证明题，如果掌握了很多的定理，很多题目都会很显然。但如果没有任何的定理，所有数学命题都只能从定义出发进行推理，那么这件事将会变得非常的难。\n而通过 lean 语言进行数学推理，DeepMind 利用强化学习，已经在几何领域中给出了成功的案例：通过强化学习生成更多的新的编码，然后学习如何利用新的编码，就可以掌握更加复杂的推理过程。\n多模态编码 当前的多模态编码完全是一种无语意的数字化编码，而且以现在关于多模态的使用方式来看，这种编码也不具备进化的能力。所以注定多模态大模型大概率不会有什么突破性的能力出现，做到极致也仅仅是远弱于人的理解能力。\n其实早期的 CV 研究，还是在沿着如何更好的对图像信息编码，甚至将编码不断演进的路子前行的。但后来在深度学习出现后，直接黑盒进行判别模型取得了远比编码的方式更优越的结果，就让大家逐渐放弃了编码这条路。\n其实今天的 LLM 带给我们的关于 CV 的启示是，或许编码这条路没有错，仅仅是曾经的我们在这条路上走得还不够远。一些关于视觉方面更好的编码特征，可能才能让多模态大模型迸发全部的能量。\n甚至更具体的说，如何能将多模态的编码与语言编码真形成对应（这就是人类或者动物真实完成的事情），然后更好的利用语言编码的能力，才能让多模态发挥更大的价值。\n更好的预测，意味着需要在原本真实物理体系的解空间中增加更多的限制，缩小解空间。单纯的图像信息不经过更好的编码是很难做到这件事情的。例如我们看到猫在跑，因为这是“猫”，所以它才会有“猫”独特的行为方式和风格，我们才得以对“猫”进行了预测。\n如果我们不能将图像对应到“猫”这样的语言编码上，那么图像的解空间是无法被控制的，预测性就大打折扣。\nAgent 编码 大语言模型在提升生产力方面最大的想象空间就是 Agent。但诸多的实践都让我们发现，真实场景下，Agent 解决问题的能力非常的有限，远不及不使用大模型的传统自动化手段更高明。\n其实这个世界中如此之多的自动化，如此之多的控制，都意味着这里天然存在某一种编码，才实现了对应的控制能力（极大的熵减）。\n大模型之于 Agent 的核心问题，是在于现在没有一套合适的编码将各种控制手段简单直接的描述出来 7。如果有更加适合的语言来描述 Agent 的控制，则可以更快的推进 Agent 的发展，真的让 LLM 带来大幅的生产力的提升。\n如果从人的实践经验来类比，SOP 就比普通的自然语言更适合作为行为指引的编码，有效的控制了解空间的大小。\n现有的相关的编码注重的都不是信息熵的多少，而是偏操作的可解析性，容错性等问题。（例如 Json，或者 AutoGPT 的每一步的结果等等）。\n这方面来说，或许从 Todo 体系 8 出发，设计一套可以引入包管理的更有利于 Agent 的编码，会是更好的解决方案。\n现在看来，这样的理解也确实有一定的问题，核心并不是压缩率，而是通过使用编码带来的熵减。 ↩︎\n不可计算是指，无法通过数据点复原动力方程。真实世界中不可计算是普遍现象，三体问题就是最简单而经典的不可计算的例子。 ↩︎\n热力学第二定律本身是一个全局的物理学定律，任何物质的运动都无法脱离于物理学存在，所以热力学第二定律是不存在真正的所谓的“逆转”的。但在局部环境下，是可以通过一些控制手段，将这些局部的熵值降低的；所付出的代价一般是对外释放了更多的热能，进而让全局的熵值变得更大了。一些具体的例子：电冰箱；星云中形成恒星等等。 ↩︎\n信息熵大，意味着这件事更难被描述，也就是客观随机发生的概率更小。而原本随机发生概率小的事被控制以更大的概率发生，则意味着系统上的降低。 ↩︎\n小数的概念要晚很多，而且小数不仅依赖分数的概念，还依赖无穷、近似等等很多数学概念的诞生。 ↩︎\n在我看来多模态的大部分编码都属于糟糕的编码。语言模型在文字水平上达到甚至超越了人，但多模态模型远不及人类的能力；以及，多模态对于 AGI 将会毫无帮助，它的编码是无法进化的，除非转化为语言。 ↩︎\n很明显人类的语言并不是自动化控制的适合编码，其中无效的信息过多，编码的熵太小。编程语言也充斥了过多的控制细节，编码的熵相对于这件事也太低。 ↩︎\n我的另一个项目就在设计类似这样一个编码。还是回到编码演化的话题，这件事不在于编码设计得有多好，而在于编码是否能持续不断的获得更好的演化。例如如果能将很多智能家居的自动化流程传唤成某种编码，那就积累了大量的使用场景和数据，自然这种编码对应的熵减就会很大，编码就更容易带来好的结果。 ↩︎\n","wordCount":"8157","inLanguage":"zh-cn","datePublished":"2024-09-18T10:38:40+08:00","dateModified":"2024-09-26T10:27:32+08:00","author":{"@type":"Person","name":"癸老师"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.uglyboy.cn/posts/2024/09/18/%E7%BC%96%E7%A0%81%E7%9A%84%E6%84%8F%E4%B9%89/"},"publisher":{"@type":"Organization","name":"拾柒读库","logo":{"@type":"ImageObject","url":"https://blog.uglyboy.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.uglyboy.cn/ accesskey=h title="拾柒读库 (Alt + H)">拾柒读库</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.uglyboy.cn/posts/ title=文章><span>文章</span></a></li><li><a href=https://blog.uglyboy.cn/slides/ title=演示><span>演示</span></a></li><li><a href=https://blog.uglyboy.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://blog.uglyboy.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.uglyboy.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.uglyboy.cn/archives/ title=时间轴><span>时间轴</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">编码的意义</h1><div class=post-description>大模型发挥能力被忽视的要素</div><div class=post-meta><span title='2024-09-18 10:38:40 +0800 CST'>2024-09-18</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;癸老师</div></header><div class=post-content><h2 id=导言>导言<a hidden class=anchor aria-hidden=true href=#导言>#</a></h2><p>伴随着大模型研究的推进和在应用中的实践，我们发现了一个现象——对于现有的 LLM 模型而言，一个好的编码可能会对其模型能力带来极大的助力。</p><p>关于这方面的思考其实由来已久，早前在听闻“压缩即智能”的论断，以及相关的数学阐述时，就产生过一种奇妙的念头：</p><ul><li>如果我们对我们正常的语言进行编码压缩，这样得到的文本信息的压缩率会更高，对压缩过的文本再进行 LLM 的训练，会发生什么？</li><li>LLM 生成的编码还能被正常的解压缩成文本吗？解压缩之后的文本还能流畅通顺吗？</li><li>这样训练出的 LLM 会不会压缩率更高？那它会更加智能吗？</li></ul><p>后来，在搞清楚了“压缩即智能” 那篇演讲，背后所提到的<strong>压缩</strong> 概念，不过是<strong>算术编码</strong>的基础运用后，这种思考便放下了 <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。</p><p>现在重新聊回编码问题，从编码的角度来看看 LLM 的本质。</p><h2 id=信息和熵>信息和熵<a hidden class=anchor aria-hidden=true href=#信息和熵>#</a></h2><p>回归到 LLM 的模型范式，过去的研究主要都将重点集中在了 Transformer 和深度学习的神奇泛化能力方面，通过更大规模的训练（Scaling Law），降低泛化误差。但究其本质，训练的逼近只是一个数值优化（压缩映射）的过程，优化的目标才是这件事起到作用的关键。</p><h3 id=llm-更应该叫大编码模型><strong>LLM</strong> 更应该叫大编码模型<a hidden class=anchor aria-hidden=true href=#llm-更应该叫大编码模型>#</a></h3><p>LLM 是信息预测模型：利用时序上已知的信息，对下一个时刻出现的信息进行预测。</p><p>但信息本身是需要被表征出来，才能进行读取（理解）和预测，而信息的表征方式就是<strong>编码</strong>。</p><blockquote><p>多模态的大模型相比于文本大模型本质上没有任何不同之处，仅仅是表达信息的编码不同，认为多模态比基于文本的大模型拥有更丰富的信息这一点是存疑的。但这一点还不是多模态大模型最大的问题。</p><p>另一个十分重要的因素，就是多模态的编码相比于语言这种编码，在进行预测时很可能天然就有十分巨大的劣势。这一点将在后文中引入了信息度量：“熵”之后，进行更深入的讨论。</p></blockquote><p>大模型的内核，正是基于已有的编码的信息，预测新的编码。预测的具体内容，是新编码出现的概率。</p><p>这里会有一个思考，不同的编码方式，是否会对预测本身的质量产生影响呢？</p><blockquote><p>从实践的角度来看，是有很大影响的。所以大语言模型都会有自已的 embedding 算法，而不是直接使用字母表或者 unicode 编码进行分析。</p><p>但我们如何从理论的解读来理解和分析这个结果呢？我们很需要引入一个能更好的描述编码相关特性的物理量。</p></blockquote><p>而在数学中刻画信息、编码、概率的模型是香农的信息论。其中最深刻的刻画就是信息熵。</p><h3 id=熵>熵<a hidden class=anchor aria-hidden=true href=#熵>#</a></h3><p>熵的概念，本质上是一个系统里单位时间内的信息密度，或者说，是我们对未来时刻进行预测的难度。</p><p>所以自然的，一个时刻出现的概率非常的低，那么这一刻我们对未来的预测就会非常的难；同时因为熵是个可描述的物理量（具有可加性），自然就会引出其常见的定义方式：</p><p>$$
H = - \sum p \ln p
$$</p><p>在这个意义下，Boltzmann 熵、Gibbs 熵 和 香农的信息熵是一致的。于是很容易引入一个十分热门的概念：<strong>热力学第二定律</strong>。</p><h4 id=热力学第二定律>热力学第二定律<a hidden class=anchor aria-hidden=true href=#热力学第二定律>#</a></h4><blockquote><p>[!tip] 热力学第二定律</p><p>在不受任何外部影响的条件下，一个系统的熵会不断增加。更具体的说，就是系统中的每个个体都会走向更加随机（概率更小），导致整个系统的可预测性越来越低。</p></blockquote><p>需要注意的是，热力学第二定律并不是一个完美的时序判别器，它是一个概率性的时间方向指引：</p><ul><li>也就是说可能会存在很多个瞬间，系统的熵减少了；</li><li>甚至一定存在某个很极端的概率事件——系统的熵一直在减少；</li></ul><p>但这些都是概率空间上的正常表现，宏观视角来看，熵的增加是稳定的。</p><p>在这种情况下，我们很容易发现，信息几乎是不可预测——随着信息中的要素的增加，想要预测下一时刻的信息所需要的信息量会按照热力学第二定律，不断增加，直至不可计算 <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。</p><blockquote><p>为了更好的理解熵和不可计算，我们以三体问题为例。</p><p>我们要想预测三体未来一小段时间的运动轨迹，所需要的信息是在这一时刻前更长一段时间的历史三体运动信息，获得的历史运动信息越多越精准，对未来的预测就能越精准，预测正确的时间就会更长一些。但永远没办法做到像计算行星轨道一样，给出公式性的结果，这种情况就属于不可计算。</p><p>从三体出发，如果想预测四体，需要比三体更加庞大的数据量才足以支撑相同时间长短的预测。随着 $n$ 体中 $n$ 的不断增长，我们能够有效的预测的时间就会越来越小。</p><p>这种现象背后的数学基础是动力系统中的混沌现象，本文不对这个问题进行更深入的解读，对此有兴趣可以参考我的《系统理论》进行理解。</p></blockquote><h3 id=编码>编码<a hidden class=anchor aria-hidden=true href=#编码>#</a></h3><p>编码不是物理学自然的结果，编码是随着生物的出现而出现的。更聚焦的说，编码是生物体对于一些固定特征合集的概括。尤其是，编码的出现，其实意味着某些固定特征合集的重复出现（高概率）。而从信息论出发，对于高概率的事件，通过编码（更短的信号）传递，就可以更高效的表达信息。</p><p>编码的出现其实也意味着人们对信息的控制（熵减）——因为编码的表达（例如动作，叫声）本身，也是编码的一部分，都属于某种小概率的行为。但当这种行为被赋予编码的含义，反过来也意味着这种行为的出现频率将会变高，于是这种行为的熵变小，进而可预测性提升。</p><p>编码不仅仅是对客体的描述，也是对客体的控制，进而在局部可以逆转 <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> 热力学第二定律。因为<strong>编码意味着一种控制行为，也就带来了可预测性的提升</strong>。</p><p>这个结论也昭示了本文的核心观点：好的编码才是 LLM 进行预测的关键。</p><blockquote><p>这也是为何 LLM 最早在 NLP 和 Coding 领域取得成功，因为这两者背后都依托于非常良好的编码。</p></blockquote><h4 id=编码的质量>编码的质量<a hidden class=anchor aria-hidden=true href=#编码的质量>#</a></h4><p>有了编码的帮助，生物就可以更好的控制自身和外部环境之间的交互，让原本更加随机不可控的生存，变得更加可控了。而这种控制的方式，就是通过编码，让随机事件中的小概率变得不那么随机（更有确定性），系统的熵降低了，但被编码的事件（信息）的熵 <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> 增加了。</p><p>所以系统更加可预测 ->系统的熵降低 ->信息编码的熵增加。</p><p>其实这件事在香农的信息论里本来就是比较显然的结果——更好的编码是按照信息的熵值大小进行编码的。甚至所谓的“压缩即智能”中的算术编码，也是自然的香农信息论的编码结果。</p><h2 id=编码的演进>编码的演进<a hidden class=anchor aria-hidden=true href=#编码的演进>#</a></h2><p>如果客观世界是无法被改变的，那么最优的编码是固定的，几乎不存在编码的选择问题。</p><p>不过编码是主观的，是生物控制自身适应环境的工具。所以编码是不断演进的，甚至编码本身的演进就是一种控制客观存在的能力的提升（例如计算机代码）。</p><p>所以我们需要从演进的视角来观察编码变化带来的价值，进而了解我们需要怎样的编码来更好的进行预测和控制。</p><h3 id=一些编码演进的案例>一些编码演进的案例<a hidden class=anchor aria-hidden=true href=#一些编码演进的案例>#</a></h3><blockquote><p>[!example] 从成语看语言的演进</p><p>各种语言的演进都是从拟声词开始的，而且这种能力并不是人类所独有，很多生物都会有自己的一些独特的信息编码表达（包括不同的叫声，也包括用排泄物标识领地等等）。</p><p>相比于动物，人类的独特之处在于创造了更多的编码，并开始组合使用这些编码。于是很多简单概念的编码就连接起来，形成了句子，形成了语言。</p><p>有了语言以后，人们就有能力更加便捷的传播信息，于是很多信息打包在一起，形成了故事，再进行传播。而这里则又出现了一次重要的编码演化——当故事传播后，它自身就成了一个编码，蕴含了远比普通的拟声表达、简单词语、句子更加丰富的内容。</p><p>这种组合，在不同的语言不同的地域有不同的表现形式，有的叫典故、有的会形成歇后语、而在汉语中，运用了一种比较独特的编码形式——<strong>成语</strong>，用四个字的方式将大量的类似的故事进行编码和传播，进一步提升了汉语的熵。</p><p>并且有了成语这种编码，再回到一般的语言表达时，句子的信息含量也得到极大的提升，甚至可以通过多个成语，再次形成新的成语，不断演进这个过程。</p></blockquote><blockquote><p>[!example] <code>Python</code> 和 <code>JavaScript</code></p><p>单从语言效率的方面来评判，<code>Python</code> 和 <code>JavaScript</code> 都算不得是很优秀的编程语言。但近些年，这两种编程语言却超越了传统的 <code>C</code>、<code>C++</code> 和 <code>Java</code>，成为了最流行的编程语言，这背后也是编码演进的功劳。</p><p>首先，<code>Python</code> 和 <code>JavaScript</code> 语言最大的特点都是入门简单，于是先天就会都拥有大量的普通用户。普通的用户对于编程语言没有很专业的训练，更需要的是简单快速可实现的能力，于是正应对上了 <code>Python</code> 和 <code>JavaScript</code> 发展中最重要的能力——包管理。</p><p>一个 <code>Python</code> 项目或者 <code>JavaScript</code> 项目，往往都会伴随一个巨大的第三方依赖文件夹，用 <code>pip</code> 或 <code>npm</code> 在项目中引入了巨量的代码，但对用户而言，在使用编程语言时，对于大量复杂的功能的使用，则只需要简单的接口或者函数就能实现，而不再需要关心各种通用功能的细节，让普通用户也可以实现复杂而高级的能力。</p><p>这种包引用的方式，其实就是编程语言的一种演进——将大量复杂的信息组合后，用新的编码来替代，就可以让编码的熵得到提升，进而让普通人也可以使用上（预测出）更可控的编码来控制外部世界。这个例子的说明了，好的编码确实可以让编码的预测性变得更好。</p><p>更直接的例子，现在无论哪种编程语言，进行数学计算时，都会直接用数学表达式进行表达，而不会用汇编将每一次的加法进行各种位移操作。这样才使得我们操控编码变得更加有效。</p></blockquote><blockquote><p>[!example] 数学</p><p>数学的发展史是极度依赖数学符号（编码）的演进的。今天的人可以比古人更明白数理，数学符号（编码）功不可没。</p><p>数学符号发展的第一步是从数演变成数字——即用具体的编码来指代不同的数量，而不是用数量本身来指代数量。这种变化才能让人类对数量的认知从 $10$ 以内（手指的数量），扩充到更多。</p><p>有了数字后，下一个重要的演进则是用不同的位置来标识不同的数字，也就是我们现在熟悉的进位制。这之后，大量级的数字才有机会被统计和计算，人类才真正将数学变成一个工具。</p><p>然后是分数的概念 <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>。或者更准确的说法，是除法的出现和表达。人们终于可以一定程度上在连续的数域上进行管理和控制。</p><p>虽然第一次数学危机引入了无理数，对数学史意义重大，但从数学的发展来看，无穷的出现和编码，才是真正的突破。有了对于无穷的理解，才有了后来牛顿的微积分（牛顿对于微积分的最重要贡献也是微积分的符号），数学才步入了近代的发展。</p><p>这之后，人们愈发理解了数学符号对数学发展的重要性，数学符号的演进也是飞速的，不再成为数学发展的掣肘。</p></blockquote><blockquote><p>[!example] 技术的演进</p><p>技术的演进其实也是编码化的——每一种新的技术都会有自己的编码描述，然后各种新技术（编码）进行重组，又会形成新的编码，提升技术的熵值，让人们可以控制更加难以控制（自然发生的概率更小）的事物。</p><p>例如元素周期表的出现就极大推动了化工以及材料、健康、能源、农业等相关产业的发展。元素周期表之前，少数的化学家也可以掌握一些物质的性质和信息，但组合使用是需要极高的门槛的。有了元素周期表，有了化学物质的新命名方式，以及更容易计算的化学反应方程，对于普通高中生而言一般的化学变化都可以轻松掌握。</p><p>类似的，每一种技术的发展，其实背后都是对应的编码的演进过程。如前面 <code>Python</code> 和 <code>JavaScript</code> 的例子是这样；工业生产、供养链、产业带的演进等等都是这样的过程。所以最终技术的成功不依赖于最初技术编码设计的是否巧妙，而是在于技术编码演进的过程中，对应的编码是否逐渐拥有了更大的熵。</p><p>以当下人类工业的顶点——光刻机为例，组装光刻机的企业并不掌握全部的工业技术，而是掌握了很多的技术编码，对编码进行组装；而上游的很多企业也只掌握了特定编码的生产，甚至也是更低级编码的组装。但足够复杂的编码构成，最终才形成了现在的可以按纳米级控制生产原件的机器的诞生。</p></blockquote><h3 id=编码的进化>编码的进化<a hidden class=anchor aria-hidden=true href=#编码的进化>#</a></h3><p>我们如何进一步提升编码的信息熵，让编码变得更好？从上文的几个案例中，其实可以找到一些共通点。</p><p>编码是需要不断组合，进而形成更加高级的概念。由此不断的可以控制客观发生概率更小的事情。</p><blockquote><p>客观的物理世界中随机出现一个 <code>iPhone</code> 手机基本是不可能的。我们人类是如何通过编码的控制创造了批量制造 <code>iPhone</code> 的方式呢？</p><p>我们需要 <code>集成电路</code> 这个编码，需要 <code>电池</code> 这个编码，需要 <code>高清屏幕</code> 这个编码，同时这些编码也不是天然存在的，是更往前的历史长河中，由更加基础的编码组合而成的。</p><p>所以当我们需要 <code>iPhone</code> 时，会拆解成 <code>集成电路</code>、<code>电池</code>、<code>高清屏幕</code>、……等等的概念，而这些概念继续拆解，直至拆解到类似于 <code>硅</code>、<code>胶水</code>、<code>玻璃</code> 等等相对基础的编码，用流程化的工程手段一步步组合成最终的高级的 <code>iPhone</code> 手机。这些编码就是人们控制生产的完整流程，有了这些编码组合，生产出 <code>iPhone</code> 就变成了一件确定性，可预测的时间了。</p></blockquote><p>编码进化的方式遵循着进化的三条基本规则：</p><ul><li><strong>自然选择</strong>：被使用得更多（概率更大）的编码会被保留下来；</li><li><strong>基因漂变</strong>：某一个编码的对应的信息会小幅度的进行一定程度的变化，以更好的适应自然选择；</li><li><strong>基因重组</strong>：形成新的编码的更高效的方式，就是两个已经存在的编码进行一定程度的关联，如果能够顺利关联上，就可以快速组合出新的优质编码。</li></ul><h3 id=编码不是信息组合>编码不是信息组合<a hidden class=anchor aria-hidden=true href=#编码不是信息组合>#</a></h3><p>从前面的分析，我们知道高级的编码是很多低级编码的组合，因此蕴含了极大的信息熵，从而更好的控制了客观世界。</p><p>那么编码仅仅是信息打包的组合吗？或者更具体的说，人们使用编码的时候，需要能完全的理解编码背后的全部低级编码组合吗？令人庆幸的是，并不需要。当一个编码形成后，编码自身就已经是独立的控制手段了。大家可以通过编码交流，但并不需要完整的交流编码背后的全部信息，即可实现信息和控制的传递。</p><blockquote><p>关于中心极限定理，其数学表达和证明并不是很显然的，也不是未经训练的人就可以快速掌握的。</p><p>但它的直接结果：<code>正太分布</code>，却可以十分常见的应用于人们对外部世界的控制。</p></blockquote><p>所以编码本身不能简单的看作是信息组合的标识符，编码存在本身就已经意味着重要的意义。</p><h3 id=进化的结果是熵减更可控>进化的结果是熵减（更可控）<a hidden class=anchor aria-hidden=true href=#进化的结果是熵减更可控>#</a></h3><p>编码的意义是指向一块小概率（自然发生的概率）的空间；通过编码进行的控制其实就是意欲将解空间限制在这块空间附近，进而提升解落在这块空间中的概率。于是编码就带来了熵减，而从应用的角度来理解，就是编码对应的行为更可控（可预测）。</p><p>而编码的进化过程，则是一种可持续的熵减演进的过程，带来结果的更加可控和可预测。</p><p>反过来这也说明了，哪怕是同一种编码，经过了不断进化后，也会提升其可预测性。这其实也反映了 LLM 的能力是收到编码的制约的——编码本身提供了可预测性的天花板。糟糕的编码 <sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> 在 LLM 中也很难取得突出的效果。</p><h2 id=编码与-llm>编码与 LLM<a hidden class=anchor aria-hidden=true href=#编码与-llm>#</a></h2><p>LLM 的目标和能力是对编码进行预测。通过上文的分析，我们已经知道，编码的作用原本就是是为了生物控制外界而诞生的；同时编码的演进方向其实也正是为了让编码变得更容易预测（增大解空间）。所以：</p><ul><li>好的 LLM 可以很好的复原编码的预测性（LLM 可以像人一样使用编码）；</li><li>好的编码可以提升 LLM 的可预测性；</li></ul><h3 id=语言编码>语言编码<a hidden class=anchor aria-hidden=true href=#语言编码>#</a></h3><p>语言编码是当下最适合 LLM 的编码。也正如我们感受到的一样，LLM 在单纯的语言能力方面，已经达到甚至超过了人的能力。</p><p>因为语言编码经过千万年的演进，已经是一个比较优良的编码了。也正是因为这个原因，LLM 才被称为 Language 模型，而不是一个编码模型。</p><p>甚至可以说，在语言编码方面，LLM 已经进化到了极致——对编码本身的利用率已经几乎压榨到底了。甚至并不需要特别大的模型，就可以很好的利用语言编码的能力了（例如 14b 以下的小模型）。</p><h3 id=code-编码>Code 编码<a hidden class=anchor aria-hidden=true href=#code-编码>#</a></h3><p>编程语言是人类设计出来的编码，同时参考了很多自然语言的用法和逻辑，尤其是有了包管理的概念后，Code 编码的演进速度甚至超过了语言编码。加上 Code 的语法相比语言更加严格（解空间更小），带来的熵减也比语言编码更多一些，所以具有更好的可预测性（可控性）。</p><p>所以 LLM 对 Code 编码的利用能力也是各种编码中最好的。面向未来的话，利用 LLM 解决 Coding 相关问题的能力一定也将会是率先迎来突破的领域（Cursor 已经初步展示了这种能力，并不需要利用更大的 LLM，现有的 LLM 甚至更小的都足够完成这种能力上的质变）。</p><h3 id=数学编码>数学编码<a hidden class=anchor aria-hidden=true href=#数学编码>#</a></h3><p>数学的逻辑推理其实是十分严格的编码语言，同时数学的各种定理也足以构成更高级的编码。在这个意义上来说，数学编码将会是未来能取得重要突破的领域。</p><p>当下的问题是，lean 语言作为数学的编码，其语料太少，非常多的基础定理都还尚未被 lean 语言描述出证明过程。这使得 LLM 可利用的编码所蕴含的熵很少，所以可预测性很低。</p><p>类似于人做证明题，如果掌握了很多的定理，很多题目都会很显然。但如果没有任何的定理，所有数学命题都只能从定义出发进行推理，那么这件事将会变得非常的难。</p><p>而通过 lean 语言进行数学推理，DeepMind 利用强化学习，已经在几何领域中给出了成功的案例：通过强化学习生成更多的新的编码，然后学习如何利用新的编码，就可以掌握更加复杂的推理过程。</p><h3 id=多模态编码>多模态编码<a hidden class=anchor aria-hidden=true href=#多模态编码>#</a></h3><p>当前的多模态编码完全是一种无语意的数字化编码，而且以现在关于多模态的使用方式来看，这种编码也不具备进化的能力。所以注定多模态大模型大概率不会有什么突破性的能力出现，做到极致也仅仅是远弱于人的理解能力。</p><p>其实早期的 CV 研究，还是在沿着如何更好的对图像信息编码，甚至将编码不断演进的路子前行的。但后来在深度学习出现后，直接黑盒进行判别模型取得了远比编码的方式更优越的结果，就让大家逐渐放弃了编码这条路。</p><p>其实今天的 LLM 带给我们的关于 CV 的启示是，或许编码这条路没有错，仅仅是曾经的我们在这条路上走得还不够远。一些关于视觉方面更好的编码特征，可能才能让多模态大模型迸发全部的能量。</p><p>甚至更具体的说，如何能将多模态的编码与语言编码真形成对应（这就是人类或者动物真实完成的事情），然后更好的利用语言编码的能力，才能让多模态发挥更大的价值。</p><blockquote><p>更好的预测，意味着需要在原本真实物理体系的解空间中增加更多的限制，缩小解空间。单纯的图像信息不经过更好的编码是很难做到这件事情的。例如我们看到猫在跑，因为这是“猫”，所以它才会有“猫”独特的行为方式和风格，我们才得以对“猫”进行了预测。</p><p>如果我们不能将图像对应到“猫”这样的语言编码上，那么图像的解空间是无法被控制的，预测性就大打折扣。</p></blockquote><h3 id=agent-编码>Agent 编码<a hidden class=anchor aria-hidden=true href=#agent-编码>#</a></h3><p>大语言模型在提升生产力方面最大的想象空间就是 Agent。但诸多的实践都让我们发现，真实场景下，Agent 解决问题的能力非常的有限，远不及不使用大模型的传统自动化手段更高明。</p><p>其实这个世界中如此之多的自动化，如此之多的控制，都意味着这里天然存在某一种编码，才实现了对应的控制能力（极大的熵减）。</p><p>大模型之于 Agent 的核心问题，是在于现在没有一套合适的编码将各种控制手段简单直接的描述出来 <sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>。如果有更加适合的语言来描述 Agent 的控制，则可以更快的推进 Agent 的发展，真的让 LLM 带来大幅的生产力的提升。</p><blockquote><p>如果从人的实践经验来类比，SOP 就比普通的自然语言更适合作为行为指引的编码，有效的控制了解空间的大小。</p></blockquote><p>现有的相关的编码注重的都不是信息熵的多少，而是偏操作的可解析性，容错性等问题。（例如 Json，或者 AutoGPT 的每一步的结果等等）。</p><p>这方面来说，或许从 Todo 体系 <sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup> 出发，设计一套可以引入包管理的更有利于 Agent 的编码，会是更好的解决方案。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>现在看来，这样的理解也确实有一定的问题，核心并不是压缩率，而是通过使用编码带来的熵减。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><strong>不可计算</strong>是指，无法通过数据点复原动力方程。真实世界中<strong>不可计算</strong>是普遍现象，三体问题就是最简单而经典的不可计算的例子。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>热力学第二定律本身是一个全局的物理学定律，任何物质的运动都无法脱离于物理学存在，所以热力学第二定律是不存在真正的所谓的“逆转”的。但在局部环境下，是可以通过一些控制手段，将这些局部的熵值降低的；所付出的代价一般是对外释放了更多的热能，进而让全局的熵值变得更大了。一些具体的例子：电冰箱；星云中形成恒星等等。&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>信息熵大，意味着这件事更难被描述，也就是客观随机发生的概率更小。而原本随机发生概率小的事被控制以更大的概率发生，则意味着系统上的降低。&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>小数的概念要晚很多，而且小数不仅依赖分数的概念，还依赖无穷、近似等等很多数学概念的诞生。&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>在我看来多模态的大部分编码都属于糟糕的编码。语言模型在文字水平上达到甚至超越了人，但多模态模型远不及人类的能力；以及，多模态对于 AGI 将会毫无帮助，它的编码是无法进化的，除非转化为语言。&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>很明显人类的语言并不是自动化控制的适合编码，其中无效的信息过多，编码的熵太小。编程语言也充斥了过多的控制细节，编码的熵相对于这件事也太低。&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>我的另一个项目就在设计类似这样一个编码。还是回到编码演化的话题，这件事不在于编码设计得有多好，而在于编码是否能持续不断的获得更好的演化。例如如果能将很多智能家居的自动化流程传唤成某种编码，那就积累了大量的使用场景和数据，自然这种编码对应的熵减就会很大，编码就更容易带来好的结果。&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.uglyboy.cn/tags/llm/>LLM</a></li><li><a href=https://blog.uglyboy.cn/tags/%E7%BC%96%E7%A0%81/>编码</a></li></ul><nav class=paginav><a class=prev href=https://blog.uglyboy.cn/posts/2024/11/06/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%8E%A8%E7%90%86%E8%83%BD%E5%8A%9B/><span class=title>« 上一页</span><br><span>大模型的推理能力</span>
</a><a class=next href=https://blog.uglyboy.cn/posts/2024/07/21/%E8%B0%88%E4%B8%80%E8%B0%88%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B8%E7%A6%8F%E7%9A%84%E5%B7%A5%E4%BD%9C/><span class=title>下一页 »</span><br><span>谈一谈什么是幸福的工作</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.uglyboy.cn/>拾柒读库</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制代码";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制代码"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>